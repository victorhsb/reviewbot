// Package cache provides a simple in-memory cache with TTL for each item.
// DISCLOSURE: all the documentation in this code was generated by github copilot
package cache

import (
	"context"
	"sync"
	"time"
)

// Item represents a cache item that holds the value and its expiration time.
type Item[T any] struct {
	Value      T     // Value is the data to be stored in the cache.
	Expiration int64 // Expiration is the Unix timestamp for when the item should expire.
}

// Cache represents a simple in-memory cache with TTL for each item.
type Cache[T any] struct {
	ttl   time.Duration       // ttl is the duration for which a cache item is valid.
	items map[string]*Item[T] // items holds the cache data.
	mu    sync.RWMutex        // mu is the read/write mutex for synchronizing access to the cache.
}

// NewCache creates a new Cache with the given TTL and maximum number of items.
// It also starts a background goroutine to clean up expired items.
func NewCache[T any](ctx context.Context, ttl time.Duration, maxItems int) *Cache[T] {
	c := &Cache[T]{
		ttl:   ttl,
		items: make(map[string]*Item[T], maxItems),
	}

	go c.startCleanupTimer(ctx)

	return c
}

// Set adds a new item to the cache with the given key and value.
// The item will expire after the cache's TTL.
func (c *Cache[T]) Set(key string, value T) {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.items[key] = &Item[T]{
		Value:      value,
		Expiration: time.Now().Add(c.ttl).UnixNano(),
	}
}

// Get retrieves an item from the cache by its key.
// It returns the item's value and a boolean indicating whether the item was found and has not expired.
func (c *Cache[T]) Get(key string) (*T, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	item, found := c.items[key]
	if !found || item.Expiration < time.Now().UnixNano() {
		return nil, false
	}

	return &item.Value, true
}

// Delete removes an item from the cache by its key.
func (c *Cache[T]) Delete(key string) {
	c.mu.Lock()
	defer c.mu.Unlock()

	delete(c.items, key)
}

// startCleanupTimer starts a background goroutine that periodically checks the cache for expired items and removes them.
// The cleanup interval is the same as the cache's TTL.
// The goroutine stops when the context is cancelled.
func (c *Cache[T]) startCleanupTimer(ctx context.Context) {
	for {
		select {
		case <-time.After(c.ttl):
			c.mu.Lock()
			now := time.Now().UnixNano()
			for key, item := range c.items {
				if now > item.Expiration {
					delete(c.items, key)
				}
			}
			c.mu.Unlock()
		case <-ctx.Done():
			return
		}
	}
}
